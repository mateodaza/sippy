## Resumen de la sesi√≥n (2025-10-16)

- Objetivo: ETH (cualquier chain) ‚Üí Arbitrum ‚Üí PYUSD ‚Üí enviar al wallet del tel√©fono.
- Estado: Bridge/transfer con Nexus estable. Swap a PYUSD se mover√° al backend para simplificar (menos UX fricci√≥n y approvals).

## Qu√© est√° funcionando hoy

- Frontend (`frontend/app/fund/page.tsx`):

  - Resoluci√≥n de tel√©fono ‚Üí address v√≠a `GET /api/resolve-phone`.
  - Bridge y transfer cross-chain con Nexus usando `sdk.transfer()` (usa `toAddress` + `toChainId`).
  - Manejo correcto de `intentModal.allow()` y `allowanceModal.allow()` con tama√±o din√°mico de allowances.
  - Trackeo de pasos de progreso (expectedSteps/stepComplete) y UI de estado.
  - Bot√≥n simplificado ‚Äúüí∞ Send 0.001 ETH as PYUSD‚Äù ahora SOLO hace bridge a Arbitrum y notifica al backend para swap+transfer.

- Librer√≠as auxiliares:

  - `frontend/lib/nexus.ts`: fix para usar `toChainId` en `sdk.bridge()` y `sdk.transfer()` cuando aplica.
  - `frontend/app/providers/NexusProvider.tsx`: inicializaci√≥n y eventos del SDK; utilidades de soporte.

- Backend (WIP):
  - Esqueleto para swap en `backend/src/commands/pyusd.command.ts` (ETH‚ÜíWETH‚ÜíPYUSD + transfer) listo para completar y cablear.
  - Ruta Next.js de proxy: `frontend/app/api/pyusd-swap/route.ts` que reenv√≠a a `BACKEND_URL/pyusd-swap`.

## Cambios clave realizados

- Correcci√≥n de API de modales: `allow()`/`deny()` (antes `confirm()`/`reject()`).
- Uso de `sdk.transfer()` cuando se especifica `toAddress` (antes `sdk.bridge()` ‚Üí enviaba a self).
- Fix de `sdk.bridge()` para usar `toChainId` correcto (evitaba puentes a Mainnet por error).
- Manejo robusto de `allowanceModal.allow()` con n√∫mero din√°mico de fuentes.
- Reemplazo de `switchChain` por `wallet_switchEthereumChain`/`wallet_addEthereumChain` para compatibilidad.
- Bot√≥n de flujo simple: bridge ETH (0.001) ‚Üí backend hace swap+transfer.

## Intentos que descartamos (para no repetir)

- Un solo intent `bridgeAndExecute` con swap Uniswap V3 en destino: fricci√≥n por approvals, ABI y edge-cases de WETH/ETH; adem√°s el SDK report√≥ ‚ÄúUser denied allowance‚Äù a√∫n aprobando.
- Swap directo USDC‚ÜíPYUSD desde UI: sensible a liquidez/montos bajos y fee tier; complejiza UX.

## Pendiente por investigar/terminar

1. Backend swap + transfer (prioritario):

   - Conectar la ruta Express a `server.ts` (importar y `app.use()`): `src/routes/pyusd.routes.ts`.
   - Asegurar `BACKEND_WALLET_PRIVATE_KEY` y `ARBITRUM_RPC` por env.
   - Confirmar ABI y uso de `SwapRouter02` en Arbitrum (`0x68b34658‚Ä¶5Fc45`).
   - Validar pool y fee tier para WETH‚ÜíPYUSD (500/3000/10000) y fallback ordenado.
   - Slippage m√≠nimo (e.g. 1‚Äì2%) y manejo de errores ‚ÄúUNPREDICTABLE_GAS_LIMIT‚Äù.

2. Agregadores alternos (evaluaci√≥n r√°pida):

   - 1inch, 0x, ParaSwap, OpenOcean (ver si listan PYUSD en Arbitrum y tienen RFQ/DEX routers con MEV protection).
   - Criterio: soporte PYUSD, endpoint simple, env√≠o a `recipient` en misma tx si posible.

3. Glue Frontend‚ÜîBackend:

   - `frontend/app/api/pyusd-swap/route.ts` toma `BACKEND_URL` (configurar en `.env.local`).
   - Manejar estados: ‚ÄúBridge OK ‚Üí Backend notified ‚Üí Swap+Transfer en progreso‚Äù.

4. Seguridad/UX:
   - Validar `recipientAddress` checksum.
   - Logs claros de explorer URLs (bridge tx / swap tx / transfer tx).
   - Retry/backoff del POST al backend si est√° fr√≠o.

## Plan de trabajo sugerido (ma√±ana)

1. Cablear backend:

   - Importar ruta en `backend/server.ts` e iniciar endpoint `/pyusd-swap`.
   - Probar local con `curl` y un monto peque√±o.

2. Completar `pyusd.command.ts`:

   - A√±adir fallback de fee tier 500‚Üí3000‚Üí10000.
   - A√±adir slippage (amountOutMinimum) calculado.
   - Loggear y devolver hashes (wrap, approve, swap, transfer).

3. End-to-end feliz:

   - UI: bridge 0.001 ETH ‚Üí ver success.
   - Next API: notifica backend ‚Üí swap+transfer ejecuta y responde.
   - UI: muestra confirmaci√≥n y resumen (recipient + tx hashes abreviados).

4. Investigaci√≥n agregadores (timebox 60‚Äì90min):
   - Chequear si alg√∫n agregador soporta ‚Äúswap & transfer‚Äù en una sola llamada en Arbitrum para PYUSD.
   - Si viable, comparar costos vs Uniswap v3 directa.

## Variables de entorno

Frontend:

```
NEXT_PUBLIC_BACKEND_URL=http://localhost:3001
```

Backend:

```
PORT=3001
BACKEND_WALLET_PRIVATE_KEY=0x...
ARBITRUM_RPC=https://arb1.arbitrum.io/rpc
```

## Comandos √∫tiles

Backend (desarrollo):

```bash
cd backend
pnpm dev
```

Frontend (desarrollo):

```bash
cd frontend
pnpm dev
```

Test r√°pido del endpoint backend (una vez cableado):

```bash
curl -X POST http://localhost:3001/pyusd-swap \
  -H 'Content-Type: application/json' \
  -d '{
    "phoneNumber": "+57...",
    "recipientAddress": "0x...",
    "amount": "0.001"
  }'
```

## Riesgos y notas

- Pools PYUSD en Arbitrum tienen liquidez variable; montos muy bajos pueden fallar sin slippage/fallback.
- Si el usuario ya tiene ETH en Arbitrum, el SDK puede saltar el bridge; el flujo actual igual funciona (solo notifica backend).
- Si necesitamos minimizar approvals: preferir WETH sobre USDC/USDT.

## Cierre

Flujo recomendado: mantener Nexus solo para bridge/transfer y mover el swap a backend (control total, menos fricci√≥n). Ma√±ana: cablear endpoint, completar swap robusto y cerrar el E2E.
